## 侦察周总结（D4-D9）

**我验证了什么？**

- 技术层面：验证了 IDA 和 X64dbg 对于软件解析的静态以及动态调试能力。
- 思维层面：对 web 和二进制进行了同一化，验证了在局部中找到关键参数，然后跳出局部，向上游寻找核心函数的重要性。
- 个人层面：对工具实现了去魅化，去除了对于自顶向下的技术层面学习的可行性担忧。

**我收获了什么？**

- 方法论：有界探索（熔断版本），环境适配的协议建立方式，向上游溯源。
- 知识：理解了 C++ `std::string` 内存布局（SSO）、简单异或加密模式、恒定时间比较算法。
- 认知：缺乏的只是在于积累性的知识，而非创造性。

**它后续如何服务主路径（Web 安全工程化）？**

- **思维迁移**：“向上溯源”的调试思维可用于深度分析 Web 协议与复杂漏洞。
- **兴趣分支**：作为保持技术广度与深度的兴趣点，每周分配有限时间接触。
- **底层理解**：对程序内存、执行流程的理解，有助于编写更稳定、高效的安全工具。

## HTTPClient类基础设置

1. **最小单位**

   类：`class`
   对象：`_init_(self,value)`；`get(self)`
   形式：

   ```python
   class HTTPClient:
       def __init__(self,value = None):
           self.value = value
   
       def get(self):
           return self.value
   
   url = HTTPClient("Hello")
   print(url.get())
   ```

1. **基础知识**

   - `request.get()`实际返回的是response对象

   - `status_code`为request类中的状态码

   - `txt`为返回的文本

   - `type`返回的是类型

   - `hasattr(对象，'属性名')`函数为内置函数，检查某一个对象是否具有属性名

   - 可以用`test = HTTPClient(NONE)`测试错误情况

1. **扩充**

   增加了3个部分：**返回状态码**，**返回reponse主文本的前200字符**，**异常响应**
   ```python
   import requests
   
   class HTTPClient:
       def __init__(self,value = None):
           self.resp = value
   
       def get(self,max_chars=200):
           try:
               if self.resp is None:
                   return "错误，未设置响应状态"
               if not hasattr(self, 'resp'):
                   return f"响应没有text属性，其属性为：{type(self.resp)}"
               if self.resp.text is None:
                   return "错误，返回text为空"
               return self.resp.text[:max_chars]
           except Exception as e:
               return f"处理失败，失败类型为:{type(e).__name__}:{e}"
   
   url = "http://httpbin.org/get"
   response = requests.get(url)
   body = HTTPClient(response)
   
   print(f"状态码是：{response.status_code}")
   print(f"结果是：{body.get(200)}")
   
   bad_client = HTTPClient(None)
   print(f"异常测试：{bad_client.get()}")
   
   ```

   运行结果：
   <img src="./assets/image-20251220161048649.png" alt="image-20251220161048649" style="zoom:50%;" />

## 多线程转发基础

1. **最小单位**

   最小单位就是以`treading`库为核心的多线程操作，相比于线程池，其痛点更多，比如返回值列表需要自己定义，需要手动`join()`，还需要索引跟踪，最小单位的话，更适合从单线程到多线程转变的底层学习，而实际应用更适合使用线程池。

2. **基础**

   - `__init__`是双下划线，self为固定格式，暂且理解为代表私有成员。必要性可以对标类和对象，类的结构创建，那么申明一个对象之后，对象便可以使用全部的成员函数，和该类所有的属性，如果不创建，则需要对该对象的每一个属性和函数都分别做定义。

   **使用treading多线程库**

   - `timeout`的用意设置请求的最大等待时间，也可以`timeout(2,5)`代表连接等待2秒，读取超过5秒，否则单参数就是连接加读取超过5秒。对于多线程的意义更大，防止因为一个导致全部卡死。
   - `treading`模块为Python的多线程模块。
   - `single_request`为单独为线程执行函数。
   - `treading.tread`为创建`tread`多线程对象。
   - `target`（多线程对象的成员）指定线程执行函数。
   - `args`（多线程对象的成员）传给函数的参数，必须是**元组**，元组就是不可变的序列，比如`(1,2,3)`,`(1,)`，`()`，`1,2,3`，相比于列表，列表可变且用方括号，使用时不可忘记逗号，
   - `start()`（多线程的成员函数）开始线程
   - `join()`（多线程的成员函数）等待线程结束

   **引入线程池后**

   - `TreadPoolExecupor`线程池管理器
   - `with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:`关键函数，作为线程池启动的方式，`executor.submit`为线程池内的标准提交函数，并返回一个结果状态。
   - `concurrent.futures.as_completed`函数通过参数（提交的返回状态）来确定对应的`future`,进而在通过一个循环，来实现扫描结果的按完成顺序进行打印。

3. **扩充**

   补充了多线程发送功能（使用线程池管理器），可以按照最大并发数进行同时发送请求，然后打印扫描的url与响应的状态码。

   ```python
   import time
   import requests
   import concurrent.futures
   
   def request_worker(url):
       try:
           response = requests.get(url,timeout=3)
           return (url,response.status_code)
       except Exception as e:
           return (url,str(e))
   
   urls = [
       "http://httpbin.org/get",
       "http://httpbin.org/status/404",
       "http://httpbin.org/dealy/2",
       "http://错误网址.abc/",
       "http://httpbin.org/delay/6"
   ]
   
   print("使用TreadPoolExecutor执行...")
   start = time.time()
   #用线程池发送
   with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
       futures = [executor.submit(request_worker,url) for url in urls]
   
       results = []
       for future in concurrent.futures.as_completed(futures):
           result = future.result()
           results.append(result)
           print(f"输出结果是{result[0]}→{result[1]}")
   
   end = time.time()
   print(f"扫描所用时间为：{end - start:.2f}秒")
   
   
   ```

   运行结果：![image-20251220210123107](./assets/image-20251220210123107.png)

