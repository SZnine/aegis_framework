## session 持久化

1. **最小模块**

   检测重定向非对象的session测试：

   ```python
   import requests
   
   session = requests.Session()
   
   print("1. 创建新会话")
   print(f"   初始cookies: {session.cookies.get_dict()}")
   
   print("第一次请求···")
   response1 = session.get("https://httpbin.org/cookies/set/name/value")
   print(f"响应1状态码：{response1.status_code}")
   print(f"当前cookies:{response1.cookies.get_dict()}")
   print(f"当前cookies整体:{response1.cookies}")
   
   
   print("第二次请求···")
   response2 = session.get("https://httpbin.org/cookies")
   print(f"响应2状态码:{response2.status_code}")
   print(f"响应的cookies文本：{response2.text}")
   print(f"当前cookies:{session.cookies.get_dict()}")
   
   print("2. 关闭重定向 (allow_redirects=False):")
   session2 = requests.Session()
   resp2 = session2.get(
       "https://httpbin.org/cookies/set/session/abc",
       allow_redirects=False
   )
   print(f"   你收到的状态码: {resp2.status_code}")      # 302 
   print(f"   你收到的URL: {resp2.url}")              # /cookies/set/session/abc
   print(f"   你收到的内容: {resp2.text[:100]}...")    # HTML重定向页
   print(f"   响应头Set-Cookie: {resp2.headers.get('Set-Cookie')}")
   print(f"   cookie已保存: {session2.cookies.get_dict()}")
   ```

   

2. **基本概念**

   - `request.Session()`:创建会话对象，自动管控cookies
   - `session.cookies.get_dict`:查看当前cookies，不是用`cookie.text`
   - `session.cookies`:返回cookie整体结构
   - `allow_redirects=False`:关闭重定向

3. **问题**

   - **重定向问题：**

     - **相当于是发生了两步响应？触发设置cookie的同时（不响应cookie），然后返回重定向页面（这是第二步）？**

       **答：**可以说是两个响应，但是只有第二个响应到了用户端，第一个在服务器端自动处理了。
     
     - **虽然重定向了，但是返回302状态的时候不是也带了cookie吗，这个cookie不会被存入session吗？**
       **答：**说白了302这个状态的响应体，我压根就没收到，而是因为开着重定向因此在服务器端直接执行跳转了。如果关闭重定向，那么会返回302状态码，内含cookie。
     
     - **session.get意思就是自带cookie的request.get吗？**
       **答：**是的。
     
     - **`__init__`到底作用是什么，和`if __name__ == "__main__"`的联动作用是什么？**
     
       **答：**方便后续被导入的时候不执行下面的main内容。而是直接使用组件好的类和对象。（相当于是仅当前文件测试执行）

4. **扩充**

无