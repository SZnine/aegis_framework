[TOC]



# **1.12**

## 建立一个基本功能的HTTPClient类，完成一个基础get功能并完成测试。

不要总依赖 AI 迭代，有时候只是一句“请以后都这样简单回答”就解决所有问题了，对迭代而追求和 AI 思想行动高度同步是会让后期变的极为被动的，不过其好处也就是方便，更容易交流，但是缺点更严重。

将 `../src/core` 作为测试源代码根目录可以直接在整个项目中随时 `import`。

先设定一个空字典作为请求头，其中的根本原因还没有确定。

`requests.exceptions.RequestException` 可以抛出全部异常，而 `requests.exceptions.HTTPError` 只会抛出状态码异常。try 中的异常会被此捕获，而不是优先被 python 异常处理。

------

**`self` 本质上的作用到底是什么，为什么 `self.response` 就会导致 `response` 实例化，就算其实例化，又有什么影响。难道是说在内存里会东一块儿西一块儿吗？**

- 实例就是对象的一个属性，应该是本质， 而不是被赋值后的一种可能带有混淆和残留的表象
- response 更适合存在于一个方法中的操作对象， 或者说，不适合被实例化，因为被赋值会导致其有残留，好比拍了一张照片，可是因为不知道是哪一次没按到快门，不知道这张照片到底是拍的谁，在多个对象访问中容易产生困惑。

**默认请求头的意思，难道是说默认发送的请求是规定好的？默认请求头不也是应该有个规则吗，对不同的网站打招呼建立连接，难道还需要不同的语言？如果是需要，那怎么知道需要用的是哪种语言，如果不是，那这种固定的打招呼模式是怎么形成的（打招呼这个想法来自于今天看的计网自顶向下黑皮书 05 部分的人类协议与计算机网络协议对比图）。**

- `header` 为空不代表请求头为空，而是指使用 `requests` 库中自带的默认的请求头，其存在的意义，就相当于是给有定制请求头需求的人提供一个可能的接口。
- `request` 库中已经设置好了足够使用的打招呼方式，而最基本的打招呼方式是通用的。

**关于抛出异常，`self.response.raise_for_status()` 这句话作用到底是什么，似乎在初始版本，这句话没有必要性，原因是什么。**

- 并不是总需要抛出异常，因为实际上是在扫描过程中可能遇到 4??或者 3??的状况是正常的，只需要抛出 2??的结果。所以本质上这是一种业务需求，不应该存在于核心模块中。

**`  # 暂时直接抛出，后续统一异常处理` 的意思难道是说，将这些涉及到异常的问题，全都归于 `exception.py` 中吗？初始阶段为了方便测试，先暂时抛出。实际上在这里最终是不需要这一部分的。**

- 和前者的答案一致，异常处理是业务需求。

**我看到在 `try` 和 `exception` 之后，用到了 `raise`，这个是什么意思**

- `raise` 相当于是等于接受了前者抛出异常这个情况，但是不做处理，如果有需求可以在此处修改。

**在 `response = requests.get(url, headers=self.headers, **kwargs)` 中，关于 `headers=self.headers`，这个可能是对之前 `self.header` 对象的使用地点，这个地方，有多种理解，但是不知道正确的是什么，关于 `**kwargs` 这一部分，之前就研究过，但是忘记了。**

- `header` 就是前面讲的，对定制需求的接口，默认是 `self.header = {}` 中定义好的。
- `**kwargs` 相当重要，相当于是用户有其他定制需求可以直接添加参数，而不需要设计者在初始函数里就定义好一个一个的形参。但是用户要注意如果可能，要确保参数不会混淆，可以用参数 = 参数值来使用参数。

# 1.15

## 完善 `post` 方法（支持 JSON 和表单数据）并且添加会话支持。

先不考虑异常抛出的各类业务需求，而是先完成一个标准模式的异常抛出模板。

------

**为什么json_data中用双引号，而在client输入header参数时用的是单引号？**
	json中严格使用双引号区分字符串和非字符串，而在python中单引号和双引号是等效的，有时用什么符号，是要看是否影响转入到json中的转义，一切为了方便省事。

**在测试代码中使用：`sys.path.insert(0,os.path.join(os.path.dirname(__file__),'src'))`的目的是什么。**
	这是一种引入核心模块的方式。不过在此项目中，我的测试文件并不在根目录，所以这句话没有起到作用，一切可以正常运行是因为我已经把核心模块添加进测试源代码根目录。

**`assert`函数所起的作用是什么，难道单纯就是一个快捷的判断语句吗？**
	`assert`是更严重的判断，是对一个客观上必须为真的事实的再次敲定，意料之外的后果并不是简单返回一个布尔值，而是中断程序，因为这种错误在根本上违反了程序设计初衷。同时，这种严格性也保证了工程上直接切断了隐性错误被忽视导致的复杂溯源问题，大大降低了可能的后期调试成本。

**为什么在测试POST的表单功能时，相比于测试JSON功能，这次并不需要自定义请求头呢？难道说演示中所使用的请求头自定义只是此功能的一种演示，而非具体功能吗？**
	确实只是对自定义header这种业务需求的演示。

**为什么在表单测试中，使用`returned = resp.json()`，而不是`returned = resp.form()`,难道说，这里其实只需要整个post中的json格式，而从中寻找表单吗，不理解，这似乎和网络报文的整体框架格式有关。**
	JSON和json不是一个东西,前者是格式，后者是字段。响应体可能是任何格式，而在此次测试中返回JSON格式，从中寻找form或者json段。

**测试会话保持中，`client = HTTPClient(default_headers={'X-Custom-Header': 'Test'})`其中的写法什么意思，就像是定义了一个参数名和一个参数值作为表单头吗？**
	相当于是提供了一个宗门令牌，至于这个令牌是进藏书阁还是长老殿，具体功能待定。不过有此令牌，日后若有需求，只需规定即可，无需开启工坊制作令牌，省了一番功夫。

------

测试结果：

![image-20260115191636828](./assets/image-20260115191636828.png)
原因是在表单测试中，对于post参数，使用了`form_data`而不是`data`，因为在post中，表单的标准参数输入模式是`data = form_data`。

修改后：
![image-20260115192229558](./assets/image-20260115192229558.png)
