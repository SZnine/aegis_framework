## C++逆向基础 · stds:: string 内存布局

自己写一个简单的字符串输入输出 cpp，运行无误后通过 ida 查看其伪代码。但是没有看到期望中的，对字符串大小进行判断的部分。

![image-20251218152738868](./assets/image-20251218152738868.png)

## 对字节字等的理解
产生了对字符串与字节等关系的疑问。，大体区别如下：

```📍 位(bit)      = 最小的快递包裹（只能装0或1）
📍 位(bit)      = 最小的快递包裹（只能装0或1）
📦 字节(byte)   = 标准快递箱（8个小包裹组成）
📮 字(word)     = 货架格子（放几个箱子，电脑决定）
🔤 字符(char)   = 包裹里的"物品描述标签"
📝 字符串       = 一整套物流单据
```

## 对 v28 |= v5 ^ password_char; 这个核心判断的理解

关键代码如下：

```pseudocode
if ( v38 == v35 )
  {
    v28 = 0;
    for ( i = 0LL; i < v38; ++i )
    {
      v4 = v37;
      if ( v39 > 0xF )
        v4 = (void **)v37[0];
      v5 = *((_BYTE *)v4 + i);
      v6 = Block;
      if ( v36 > 0xF )
        v6 = (void **)Block[0];
      v28 |= v5 ^ *((_BYTE *)v6 + i);
    }
    v2 = v28 == 0;
    v0 = v38;
    v1 = v35;
  }
```
相当于是：

```pseudocode
for (每个字符) {
    diff |= a[i] ^ b[i];  // 总是比较所有字符
}
return diff == 0;
```
其中v5作为用户输入，后者*((_BYTE *)v6 + i)作为对应位的正确密码，两者异或值在每次循环中逐个相或，只有每一位都正确，才能保证v28为0，否则，v2不等于1，无法进入后面的密码正确的判断循环。这个作用主要就是为了防止利用时间差对密码进行暴力破解。至于`*((_BYTE *)v6 + i)`就属于时c++中字符串内存分配问题，大于实际操作系统位数，进行堆放置，并且原来其中最开始放的字符串数据位变为对应堆的数据指针数，其后的话，大体就是字符串长度，还有容量标志等，这在不同操作系统中可能会有不通。

## 对伪代码 v1，v2，v3 不同意义的解释

学会了新方法：对v1 v2 v3等不同变量，发现作用可以进行重命名方便后续分析。
v后面加什么，只是ida反编译过程中为了方便而产生的一系列变量名，并无真实的特指意义，具体还需要看在对应的代码片段中起什么作用。比如上面代码中`v38 == v35`，其中的`v35`和`v38`就代表了用户输入字符串的长度和真实密码的字符串长度。

## 为何循环每个字符串比较而不是直接比较

主要还是安全问题，不把密钥等敏感信息直接分析。

## 如何通过时间差来推断密码

通过逐个输入，比如'a','b'.....'e','ea','eb'，如果时间相同，证明这一位都错了， 当进入下一位判断时，时间增加，证明这一位正确，应用于暴力破解。

