不要总依赖 AI 迭代，有时候只是一句“请以后都这样简单回答”就解决所有问题了，对迭代而追求和 AI 思想行动高度同步是会让后期变的极为被动的，不过其好处也就是方便，更容易交流，但是缺点更严重。

将 `../src/core` 作为测试源代码根目录可以直接在整个项目中随时 `import`。

先设定一个空字典作为请求头，其中的根本原因还没有确定。

`requests.exceptions.RequestException` 可以抛出全部异常，而 `requests.exceptions.HTTPError` 只会抛出状态码异常。try 中的异常会被此捕获，而不是优先被 python 异常处理。

------

`self` 本质上的作用到底是什么，为什么 `self.response` 就会导致 `response` 实例化，就算其实例化，又有什么影响。难道是说在内存里会东一块儿西一块儿吗？

- 实例就是对象的一个属性，应该是本质， 而不是被赋值后的一种可能带有混淆和残留的表象
- response 更适合存在于一个方法中的操作对象， 或者说，不适合被实例化，因为被赋值会导致其有残留，好比拍了一张照片，可是因为不知道是哪一次没按到快门，不知道这张照片到底是拍的谁，在多个对象访问中容易产生困惑。

默认请求头的意思，难道是说默认发送的请求是规定好的？默认请求头不也是应该有个规则吗，对不同的网站打招呼建立连接，难道还需要不同的语言？如果是需要，那怎么知道需要用的是哪种语言，如果不是，那这种固定的打招呼模式是怎么形成的（打招呼这个想法来自于今天看的计网自顶向下黑皮书 05 部分的人类协议与计算机网络协议对比图）。

- `header` 为空不代表请求头为空，而是指使用 `requests` 库中自带的默认的请求头，其存在的意义，就相当于是给有定制请求头需求的人提供一个可能的接口。
- `request` 库中已经设置好了足够使用的打招呼方式，而最基本的打招呼方式是通用的。

关于抛出异常，`self.response.raise_for_status()` 这句话作用到底是什么，似乎在初始版本，这句话没有必要性，原因是什么。

- 并不是总需要抛出异常，因为实际上是在扫描过程中可能遇到4??或者3??的状况是正常的，只需要抛出2??的结果。所以本质上这是一种业务需求，不应该存在于核心模块中。

`  # 暂时直接抛出，后续统一异常处理` 的意思难道是说，将这些涉及到异常的问题，全都归于 `exception.py` 中吗？初始阶段为了方便测试，先暂时抛出。实际上在这里最终是不需要这一部分的。

- 和前者的答案一致，异常处理是业务需求。

我看到在 `try` 和 `exception` 之后，用到了 `raise`，这个是什么意思

- `raise`相当于是等于接受了前者抛出异常这个情况，但是不做处理，如果有需求可以在此处修改。

在 `response = requests.get(url, headers=self.headers, **kwargs)` 中，关于 `headers=self.headers`，这个可能是对之前 `self.header` 对象的使用地点，这个地方，有多种理解，但是不知道正确的是什么，关于 `**kwargs` 这一部分，之前就研究过，但是忘记了。

- `header`就是前面讲的，对定制需求的接口，默认是`self.header = {}`中定义好的。
- `**kwargs`相当重要，相当于是用户有其他定制需求可以直接添加参数，而不需要设计者在初始函数里就定义好一个一个的形参。但是用户要注意如果可能，要确保参数不会混淆，可以用参数=参数值来使用参数。
