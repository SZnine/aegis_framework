## CrackMe难度3挑战（c++用户名-序列号验证）

**软件运行图：**

<img src="./assets/image-20251219150527069.png" alt="image-20251219150527069" style="zoom:50%;" />

**关键代码：**

```pseudocode
GetWindowTextA(::hWnd, (LPSTR)String, 256);
        GetWindowTextA(qword_14037EF58, v23, 256);
        v6 = strlen((const char *)String);
        left = String[0].left;
        if ( LOBYTE(String[0].left) )
        {
          v8 = -v6;
          v9 = -559038242;
          v10 = 1431655765;
          v11 = 0LL;
          do
          {
            if ( (left & 1) != 0 )
              v12 = left + __ROL4__(v10, 29) - 439041101;
            else
              v12 = (left ^ __ROL4__(v10, 12)) - 1863314892;
            v9 = (v11 + v9) ^ (v11 + v9 + v8);
            v10 = v9 ^ v12;
            left = *((_BYTE *)&String[0].left + ++v11);
          }
          while ( left );
        }
        else
        {
          v10 = 1431655765;
          v9 = -559038242;
          LODWORD(v11) = 0;
        }
        if ( ((255 * (_DWORD)v11 * (_DWORD)v11) ^ (v9 + __ROL4__(v10, 29))) == strtoul(v23, 0LL, 16) )
        {
          v18 = "Access Granted!";
          v19 = "Success";
          v20 = hWnd;
          v21 = 64;
        }
        else
        {
          v18 = "Invalid Key";
          v19 = "Failed";
          v20 = hWnd;
          v21 = 16;
        }
```

主要逻辑分为两部分，**第一部分**是利用一个序列号生成算法对输入的用户名进行处理，转化位一个序列号，也就是` ((255 * (_DWORD)v11 * (_DWORD)v11) ^ (v9 + __ROL4__(v10, 29)))`，在**第二部分**对序列号进行校验，和用户输入的key进行比较，若一致，返回`"Success"`,若不一致，返回`"Failed"`。

在CrackMe中，其算法偏简单，目前虽然有很多商用软件，也使用注册机，但是其算法更为复杂。

在这道题目分析过程中，遇到的主要问题是，对一些字符还不是很熟悉，比如` left = String[0].left;`,还有序列号计算中的`*`有时候会和指针混淆，还有` GetWindowTextA(::hWnd, (LPSTR)String, 256);`这种输入方式，对其中各部分不是很清晰，还有`left = *((_BYTE *)&String[0].left + ++v11);`其中的`++v11`这种运算方式的具体先后顺序，只是直到大概的意思，但是不能准确。

## D3web回顾

对于web安全中写扫描器这个东西，我认为更像是在二进制中已经比较成熟的一些工具链，扫描器做的就是根据选定的范围，条件，去筛选出符合自己想法的一些特定端口，这与一些内存扫描工具的性质相似，我想要修改一个程序，本质上也是对一个特定条件的目标内存进行筛选，找到一个范围，再根据适当的修改和反馈信息，来判断有效的攻击手段。当然这并非指代全部的web安全或者二进制，而是指这一周多的时间，我接触到的范围，做出的分析。